# -------------
# Actions
# -------------

enum ActionType {
  Buy
  Sell
  Resell
  Mint
  Unmint
  AddLiquidity
  RemoveLiquidity
  Exercise
  Withdraw
  TransferFrom
  TransferTo
}

type Metadata @entity {
  id: ID!
  optionsMintedAndSold: BigInt
}

type Action @entity {
  id: ID!
  type: ActionType!
  user: User!
  option: Option!
  pool: Pool

  from: Bytes!
  hash: Bytes!
  timestamp: Int!

  # Input for Option Tokens (A)
  inputTokenA: BigInt!
  # Input for Stablecoin Tokens (B)
  inputTokenB: BigInt!
  # Output for Option Tokens (A)
  outputTokenA: BigInt!
  # Output for Stablecoin Tokens (A)
  outputTokenB: BigInt!
  # Spot price at the time of the trade
  spotPrice: SpotPrice
  # Special metadata on a case-by-case basis
  metadata: Metadata

  ##### NEXT VALUES POST-ACTION ####

  # Track next Implied Volatility
  nextIV: BigInt

  # Track next Premium
  nextSellingPrice: BigInt #For one option
  nextBuyingPrice: BigInt #For one option
  nextDynamicSellingPrice: BigInt
  nextDynamicBuyingPrice: BigInt

  nextUserTokenALiquidity: BigInt
  nextUserTokenBLiquidity: BigInt

  nextTBA: BigInt
  nextTBB: BigInt

  nextDBA: BigInt
  nextDBB: BigInt

  nextFeesA: BigInt
  nextFeesB: BigInt

  nextCollateralTVL: BigInt
  nextPoolTokenATVL: BigInt
  nextPoolTokenBTVL: BigInt

  nextUserSnapshotFIMP: BigInt
  nextUserTokenAOriginalBalance: BigInt
  nextUserTokenBOriginalBalance: BigInt

  nextABPrice: BigInt
}

type SpotPrice @entity {
  id: ID!
  value: BigInt!
  action: Action
}

# -------------
# Elements
# -------------

type Manager @entity {
  id: ID!
  configurations: [Configuration!]! @derivedFrom(field: "manager")
  configuration: Configuration!
}

type Configuration @entity {
  id: ID!
  manager: Manager!

  owner: Bytes
  optionFactory: OptionFactory
  optionHelper: OptionHelper
  poolFactory: PoolFactory

  timestamp: Int!
}

type OptionFactory @entity {
  id: ID!
  options: [Option!] @derivedFrom(field: "factory")
}

type OptionHelper @entity {
  id: ID!
}

type PoolFactory @entity {
  id: ID!
  pools: [Pool!] @derivedFrom(field: "factory")
}

type Option @entity {
  "unique identifier, resolving to the option address"
  id: ID!
  "address of the option"
  address: Bytes!
  "address of the deployer"
  from: Bytes!

  "binary type, resolving to 0 for PUT and 1 for CALL"
  type: Int!
  "decimals of the ERC20 option token, usually 18"
  decimals: BigInt!
  "symbol for the ERC20 option token"
  symbol: String!

  "address of the underlying ERC20 token"
  underlyingAsset: Bytes!
  "address of the strike ERC20 token"
  strikeAsset: Bytes!

  "decimals of the underlying ERC20 token"
  underlyingAssetDecimals: BigInt!
  "decimals of the strike ERC20 token"
  strikeAssetDecimals: BigInt!

  "symbol of the underlying ERC20 token"
  underlyingAssetSymbol: String!
  "symbol of the strike ERC20 token"
  strikeAssetSymbol: String!

  "amount used as strike price"
  strikePrice: BigInt!

  "amount resolving to the unix timestamp (millis) used as expiration"
  expiration: Int!
  "amount resolving to the duration (millis) used for the window of exercise"
  exerciseWindowSize: Int!

  # Generated or Bound
  "actions such as Buy, Sell, Mint, ... linked to the option or the connected pool"
  actions: [Action!]! @derivedFrom(field: "option")
  "positions of the users (with >= 1 action) linked to the option or the connected pool"
  positions: [Position!] @derivedFrom(field: "option")
  "aggregate activity on an hourly basis"
  hourActivity: [OptionHourActivity!] @derivedFrom(field: "option")
  "aggregate activity on a daily basis"
  dayActivity: [OptionDayActivity!] @derivedFrom(field: "option")
  "pool connected to the option 1:1"
  pool: Pool
  "amount resolving to the unix timestamp (millis) used as start moment for the window of exercise"
  exerciseStart: Int

  "address of the inferred collateral ERC20 token (strike for PUT, underlying for CALL)"
  collateralAsset: Bytes!
  "decimals of the inferred collateral ERC20 token"
  collateralAssetDecimals: BigInt!
  "symbol of the inferred collateral ERC20 token"
  collateralAssetSymbol: String!

  "factory (option factory) creating the option"
  factory: OptionFactory!
}

type Pool @entity {
  # Created
  id: ID!
  from: Bytes!
  address: Bytes!
  option: Option!
  factory: PoolFactory!

  tokenA: Bytes!
  tokenB: Bytes!

  tokenADecimals: BigInt!
  tokenBDecimals: BigInt!

  tokenASymbol: String!
  tokenBSymbol: String!
}

type User @entity {
  id: ID!
  address: Bytes!
  # Generated or Bound
  actions: [Action!] @derivedFrom(field: "user")
  positions: [Position!] @derivedFrom(field: "user")
}

type Position @entity {
  id: ID!
  user: User!
  option: Option!
  # Expiration chosen as sortable param *cloned* from the option
  expiration: Int!

  # # # # # # # # #
  # Buyer's premium
  premiumPaid: BigInt!
  # Seller's premium
  premiumReceived: BigInt!
  #
  # Buyer's cover
  optionsBought: BigInt!
  # Seller's goods
  optionsSold: BigInt!
  # Reseller's goods
  optionsResold: BigInt!
  #
  # Minter's lock
  optionsMinted: BigInt!
  # Minter's release
  optionsUnminted: BigInt!
  #
  # Exerciser options
  optionsExercised: BigInt!
  # Withdraw amounts
  underlyingWithdrawn: BigInt!
  collateralWithdrawn: BigInt!
  #
  # LP's input amounts
  initialOptionsProvided: BigInt!
  initialTokensProvided: BigInt!
  #
  # LP's output/exit amounts
  finalOptionsRemoved: BigInt!
  finalTokensRemoved: BigInt!
  #
  # Transfers
  optionsSent: BigInt! # TransferFrom
  optionsReceived: BigInt! # TransferTo
}

type OptionHourActivity @entity {
  id: ID!
  option: Option!

  timestamp: Int!
  day: Int!
  hour: Int!

  hourlyPremiumReceived: BigInt!
  hourlyPremiumPaid: BigInt!

  hourlyGrossVolumeOptions: BigInt!
  hourlyGrossVolumeTokens: BigInt!

  hourlyActionsCount: BigInt!
}

type OptionDayActivity @entity {
  id: ID!
  option: Option!

  timestamp: Int!
  day: Int!

  dailyPremiumReceived: BigInt!
  dailyPremiumPaid: BigInt!

  dailyGrossVolumeOptions: BigInt!
  dailyGrossVolumeTokens: BigInt!

  dailyActionsCount: BigInt!
}
